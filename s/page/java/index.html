<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>java各種小知識 &middot; Dixen</title>

  
  <link rel="stylesheet" href="https://dixentw.github.io/css/poole.css">
  <link rel="stylesheet" href="https://dixentw.github.io/css/hyde.css">
  <link rel="stylesheet" href="https://dixentw.github.io/css/poole-overrides.css">
  <link rel="stylesheet" href="https://dixentw.github.io/css/hyde-overrides.css">
  <link rel="stylesheet" href="https://dixentw.github.io/css/hyde-x.css">
  <link rel="stylesheet" href="https://dixentw.github.io/css/highlight/sunburst.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://dixentw.github.io/touch-icon-144-precomposed.png">
  <link href="https://dixentw.github.io/favicon.png" rel="icon">

  
  
  
  

  <meta name="description" content="">
  <meta name="keywords" content="">
  
</head>
<body class="theme-base-0d">
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      
        <img src="https://www.gravatar.com/avatar/01bd6f50f32068f5daf02ff29365ce53?s=200"
             alt="gravatar" title="Dixen">
      
      <h1>Dixen</h1>
      <p class="lead">拿來記工作流水帳，或各種與軟體工作有關的事情</p>
    </div>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item"><a href="https://dixentw.github.io/">Blog</a></li>
      
      <li class="sidebar-nav-item"><a href="https://dixentw.github.io/leetcode/">Leetcode</a></li>
      
      <li class="sidebar-nav-item"><a href="https://dixentw.github.io/page/">Page</a></li>
      
      <li class="sidebar-nav-item"><a href="https://dixentw.github.io/post/">Post</a></li>
      
    </ul>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
      <a href="https://github.com/dixentw"><i class="fa fa-github-square fa-3x"></i></a>
      
      
      
      
      
      
      
      
      </li>
    </ul>

    

    <p>Copyright &copy; 2016 <a href="https://dixentw.github.io/license/">License</a><br/>
       Powered by <a href="http://gohugo.io">Hugo</a> and <a href="https://github.com/zyro/hyde-x">Hyde-X</a></p>
  </div>
</div>


<div class="content container">
  <div class="post">
    <h1 class="post-title">java各種小知識</h1>
    

<h3 id="garbage-collection:2fe63a086631fd317b5011f46eddfec4">Garbage collection</h3>

<h3 id="thread-things:2fe63a086631fd317b5011f46eddfec4">Thread Things</h3>

<ol>
<li><p>注意事項分類</p>

<ol>
<li>盡量使用local primative variable, 有reference的object就不一定。</li>

<li><p>TheadLocal Class使用方法，看例子：</p>

<pre><code>public class Solution{
public static class MyRunner implements Runnable{
    private ThreadLocal&lt;Double&gt; localInt = new ThreadLocal&lt;Double&gt;();
    private double noProtect = 0.0;
    @Override
    public void run(){
        double d = Math.random();
        System.out.println(d);
        noProtect = d;
        localInt.set(d);
        try{
            Thread.sleep(1000);
        }catch(InterruptedException e){
            //nothing here now
        }
        System.out.println(localInt.get());
        System.out.println(noProtect);
    }
}
public static void go() throws Exception{
    MyRunner m1 = new MyRunner();
    Thread thread1 = new Thread(m1);
    Thread thread2 = new Thread(m1);


    thread1.start();
    thread2.start();


    thread1.join(); //wait for thread 1 to terminate
    thread2.join(); //wait for thread 2 to terminate
}
}
</code></pre></li>

<li><p>需要share的情況怎麼辦？</p>

<ol>
<li>要取用大家共用的object，使用synchronized比較好（但比較慢）</li>

<li><p>Volatile <img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-6.png" alt="記憶體的圖" /></p>

<ul>
<li>因為現在的電腦有多個cpu, 還有cpu-memory cache, 所以某個thread要是修改了某個variable, 要確定在每個thread都看到的話，就需要volatile這個關鍵字</li>
</ul></li>

<li><p>multi-thread的volatile必須synchronized, 不然就race condition了</p></li>
</ol></li>
</ol></li>

<li><p>Thread 控制:</p>

<ul>
<li><p>Object的<code>notify()</code>, <code>wait()</code>, <code>notifyAll()</code>, 與另外一個什麼我現在忘了..</p>

<ul>
<li>Signaling via Shared Objects: 若B thread要等A thread做完某事，才能接手，此刻，他們需要共同reference一個object, 然後set這個object的value，讓另外一個thread看，另外一個thread要polling這個variable, 此為busy wait。</li>
<li>wait and notify, example: （必須使用synchronized!!! 某thread要可以wait, notify, 必須要有該物件的lock)<br /></li>
</ul>

<pre><code>class Q {
    int n;
    boolean valueSet = false;
    synchronized int get() {
        while(!valueSet){
            try {
                wait();
            } catch(InterruptedException e) {
                System.out.println(&quot;InterruptedException caught&quot;);
            }
        }
        System.out.println(&quot;Got: &quot; + n);
        valueSet = false;
        notify();
        return n;
    }
    synchronized void put(int n) {
        while(valueSet){
            try {
                wait();
            } catch(InterruptedException e) {
                System.out.println(&quot;InterruptedException caught&quot;);
            }
        }
        this.n = n;
        valueSet = true;
        System.out.println(&quot;Put: &quot; + n);
        notify();
    }
}
class Producer implements Runnable {
    Q q;
    Producer(Q q) {
        this.q = q;
        new Thread(this, &quot;Producer&quot;).start();
    }
    public void run() {
        int i = 0;
        while(true) {
            q.put(i++);
        }
    }
}
class Consumer implements Runnable {
    Q q;
    Consumer(Q q) {
        this.q = q;
        new Thread(this, &quot;Consumer&quot;).start();
    }
    public void run() {
        while(true) {
            q.get();
        }
    }
}
class PCFixed {
    public static void main(String args[]) {
        Q q = new Q();
        new Producer(q);
        new Consumer(q);
        System.out.println(&quot;Press Control-C to stop.&quot;);
    }
}
</code></pre>

<ul>
<li>idiom<br /></li>
</ul>

<pre><code>synchronized (sharedObject) {
    while (condition) {
           sharedObject.wait();
           // (Releases lock, and reacquires on wakeup)
    }
    // do action based upon condition e.g. take or put into queue
}
</code></pre></li>
</ul></li>
</ol>

<h3 id="data-structure:2fe63a086631fd317b5011f46eddfec4">Data Structure</h3>

<ul>
<li>transient?</li>
</ul>

<h3 id="oo-principle:2fe63a086631fd317b5011f46eddfec4">OO principle</h3>

<ul>
<li>polymorphism <a name="poly"></a>

<ol>
<li>利用父類別的型態</li>
<li>接受子類別的物件</li>
<li>做相同的動作</li>
<li>引發不同的行為</li>
</ol></li>
</ul>

<h3 id="design-pattern:2fe63a086631fd317b5011f46eddfec4">Design Pattern</h3>

<ul>
<li>Strategy</li>
<li>Decorator</li>
</ul>

<h3 id="面經:2fe63a086631fd317b5011f46eddfec4">面經</h3>

<ol>
<li>九种基本数据类型的大小，以及他们的封装类。

<ul>
<li>byte  1byte, 8-bits</li>
<li>short 2bytes</li>
<li>int   4bytes</li>
<li>long  8bytes</li>
<li>float 4bytes</li>
<li>double    8bytes</li>
<li>boolean   true/false 1 bit</li>
<li>char  16-bit, 2bytes</li>
</ul></li>
<li>Switch能否用string做参数？

<ul>
<li>從JDK 7 之後就可以了</li>
</ul></li>
<li>equals与==的区别。

<ul>
<li>== compare with reference, equals compare the string value</li>
</ul></li>
<li>Object有哪些公用方法？

<ul>
<li>othres:

<ul>
<li>clone() : 複製</li>
<li>equals() : 實作物件的相等</li>
<li>finalize() : GC要回收這個object的時候會call這個method</li>
<li>getClass() :</li>
<li>hashCode() :</li>
<li>toString()</li>
</ul></li>
<li>thread:

<ul>
<li>notify() : 把在等這個物件的thread叫醒</li>
<li>notifyAll() : 對全部在等這個物件的thread叫醒</li>
<li>wait() : 讓現在在用的thread睡著</li>
</ul></li>
</ul></li>
<li>Java的四种引用(reference)，强弱软虚，用到的场景。

<ul>
<li>normal Reference : 正常物件有的reference，既然有，GC就不會回收這個物件</li>
<li>Soft Reference :</li>
<li>Weak Reference : 當某物件只剩下weak reference, GC會把它清掉
<code>
Car car = new Car(22000,&quot;silver&quot;);  
WeakReference&lt;Car&gt; weakCar = new WeakReference&lt;Car&gt;(car);
int i=0;  
while(true){  
    if(weakCar.get()!=null){  
        i++;  
        System.out.println(&quot;Object is alive for &quot;+i+&quot; loops - &quot;+weakCar);  
    }else{  
        System.out.println(&quot;Object has been collected.&quot;);  
        break;  
    }  
}  
</code></li>
<li>Phantom Reference</li>
</ul></li>
<li>Hashcode的作用

<ul>
<li>在使用collector的時候，如Set, 要保證放進Set的物件不重複，必須調用這個method, 理論上這個method每個物件出來的value要不同</li>
</ul></li>
<li>ArrayList、LinkedList、Vector的区别。

<ul>
<li>List : is an ordered sequence of elements</li>
<li>ArrayList : list implemented with resizable array.</li>
<li>LinkedList : list implemented with double linked list. better add/remove time than arraylist, slower for get/set</li>
<li>LinkedList

<ul>
<li>get is O(n)</li>
<li>add is O(1)</li>
<li>remove is O(n)</li>
</ul></li>
<li>ArrayList

<ul>
<li>get is O(1)</li>
<li>add is O(1), but with array resize, will be O(n)</li>
<li>remove is O(n)</li>
</ul></li>
<li>Vector:

<ul>
<li>almost arraylist, with synchronized, 對於thread safe的場景，使用arraylist會比較好</li>
</ul></li>
</ul></li>
<li>String、StringBuffer与StringBuilder的区别。

<ul>
<li>String: the length cannot be modified</li>
<li>StringBuffer: faster when you want to frequently modified a String, thread-safe</li>
<li>StringBuilder: almost the same with StringBuffer, not thread-safe</li>
</ul></li>
<li>Map、Set、List、Queue、Stack的特点与用法。

<ul>
<li>Map - key, value one-on-one mapping.</li>
<li>Set - save non-duplicated elements, not preserve their order.</li>
<li>List - save elements with order, the element and be duplicated.</li>
<li>Queue - interface with offer, poll, peak. ArrayList is one of implementation.</li>
<li>Stack - based on Vector, implement First In Last Out fashion.</li>
</ul></li>
<li>HashMap和HashTable的区别。

<ul>
<li>They are Map interface implementation.</li>
<li>HashTable : thread-safe, cannot store null</li>
<li>HashMap : non- threadsafe, can store null</li>
</ul></li>
<li>HashMap和ConcurrentHashMap的区别，HashMap的底层源码。</li>
<li>TreeMap、HashMap、LindedHashMap的区别。</li>
<li>Collection包结构，与Collections的区别。</li>
<li>try catch finally，try里有return，finally还执行么？</li>
<li>Excption与Error包结构。OOM你遇到过哪些情况，SOF你遇到过哪些情况。 -&gt; 太偏</li>
<li>Java面向对象的三个特征与含义。</li>
<li>Override和Overload的含义去区别。

<ul>
<li>override: sub class extend super class&rsquo;s function(change behavior or specify task)</li>
<li>overload: member functions may have the same name if there parameters are different.</li>
</ul></li>
<li>Interface与abstract class的区别。

<ul>
<li>interface:</li>
<li>abstract class:</li>
</ul></li>
<li>Static class 与non static class的区别。</li>
<li>java多态的实现原理。 請見<a href="#poly">上面</a></li>
<li>实现多线程的两种方法：Thread与Runable。</li>
<li>线程同步的方法：sychronized、lock、reentrantLock等。</li>
<li>锁的等级：方法锁、对象锁、类锁。</li>
<li>写出生产者消费者模式。</li>
<li>ThreadLocal的设计理念与作用。</li>
<li>ThreadPool用法与优势。</li>
<li>Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等。</li>
<li>wait()和sleep()的区别。</li>
<li>foreach与正常for循环效率对比。</li>
<li>Java IO与NIO。</li>
<li>反射的作用于原理。</li>
<li>泛型常用特点，List<String>能否转为List<Object>。</li>
<li>解析XML的几种方式的原理与特点：DOM、SAX、PULL。</li>
<li>Java与C++对比。</li>
<li>Java1.7与1.8新特性。</li>
<li>设计模式：单例、工厂、适配器、责任链、观察者等等。</li>
<li>JNI的使用。</li>
</ol>

<p>JVM
1. 内存模型以及分区，需要详细到每个区放什么。
2. 堆里面的分区：Eden，survival from to，老年代，各自的特点。
3. 对象创建方法，对象的内存分配，对象的访问定位。
4. GC的两种判定方法：引用计数与引用链。
5. GC的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？
6. GC收集器有哪些？CMS收集器与G1收集器的特点。
7. Minor GC与Full GC分别在什么时候发生？
8. 几种常用的内存调试工具：jmap、jstack、jconsole。
9. 类加载的五个过程：加载、验证、准备、解析、初始化。
10. 双亲委派模型：Bootstrap ClassLoader、Extension ClassLoader、ApplicationClassLoader。
11. 分派：静态分派与动态分派。
JVM过去过来就问了这么些问题，没怎么变，内存模型和GC算法这块问得比较多，可以在网上多找几篇博客来看看。
推荐书籍：《深入理解java虚拟机》</p>

<p>操作系统
1. 进程和线程的区别。
2. 死锁的必要条件，怎么处理死锁。
3. Window内存管理方式：段存储，页存储，段页存储。
4. 进程的几种状态。
5. IPC几种通信方式。
6. 什么是虚拟内存。
7. 虚拟地址、逻辑地址、线性地址、物理地址的区别。
因为是做android的这一块问得比较少一点，还有可能上我简历上没有写操作系统的原因。
推荐书籍：《深入理解现代操作系统》</p>

<p>TCP/IP
1. OSI与TCP/IP各层的结构与功能，都有哪些协议。
2. TCP与UDP的区别。
3. TCP报文结构。
4. TCP的三次握手与四次挥手过程，各个状态名称与含义，TIMEWAIT的作用。
5. TCP拥塞控制。
6. TCP滑动窗口与回退N针协议。
7. Http的报文结构。
8. Http的状态码含义。
9. Http request的几种类型。
10. Http1.1和Http1.0的区别
11. Http怎么处理长连接。
12. Cookie与Session的作用于原理。
13. 电脑上访问一个网页，整个过程是怎么样的：DNS、HTTP、TCP、OSPF、IP、ARP。
14. Ping的整个过程。ICMP报文是什么。
15. C/S模式下使用socket通信，几个关键函数。
16. IP地址分类。
17. 路由器与交换机区别。</p>

<p>网络其实大体分为两块，一个TCP协议，一个HTTP协议，只要把这两块以及相关协议搞清楚，一般问题不大。
推荐书籍：《TCP/IP协议族》</p>

<p>数据结构与算法
1. 链表与数组。
2. 队列和栈，出栈与入栈。
3. 链表的删除、插入、反向。
4. 字符串操作。
5. Hash表的hash函数，冲突解决方法有哪些。
6. 各种排序：冒泡、选择、插入、希尔、归并、快排、堆排、桶排、基数的原理、平均时间复杂度、最坏时间复杂度、空间复杂度、是否稳定。
7. 快排的partition函数与归并的Merge函数。
8. 对冒泡与快排的改进。
9. 二分查找，与变种二分查找。
10. 二叉树、B+树、AVL树、红黑树、哈夫曼树。
11. 二叉树的前中后续遍历：递归与非递归写法，层序遍历算法。
12. 图的BFS与DFS算法，最小生成树prim算法与最短路径Dijkstra算法。
13. KMP算法。
14. 排列组合问题。
15. 动态规划、贪心算法、分治算法。（一般不会问到）
16. 大数据处理：类似10亿条数据找出最大的1000个数&hellip;&hellip;&hellip;等等
算法的话其实是个重点，因为最后都是要你写代码，所以算法还是需要花不少时间准备，这里有太多算法题，写不全，我的建议是没事多在OJ上刷刷题（牛客网、leetcode等），剑指offer上的算法要能理解并自己写出来，编程之美也推荐看一看。
推荐书籍：《大话数据结构》《剑指offer》《编程之美》</p>

  </div>
</div>
<script src="https://dixentw.github.io/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>

