<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pages on 工作日誌</title>
    <link>https://dixentw.github.io/s/page/</link>
    <description>Recent content in Pages on 工作日誌</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 07 May 2016 15:28:03 +0800</lastBuildDate>
    <atom:link href="https://dixentw.github.io/s/page/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>java各種小知識</title>
      <link>https://dixentw.github.io/s/page/java/</link>
      <pubDate>Sat, 07 May 2016 15:28:03 +0800</pubDate>
      
      <guid>https://dixentw.github.io/s/page/java/</guid>
      <description>

&lt;h3 id=&#34;garbage-collection:2fe63a086631fd317b5011f46eddfec4&#34;&gt;Garbage collection&lt;/h3&gt;

&lt;h3 id=&#34;thread-things:2fe63a086631fd317b5011f46eddfec4&#34;&gt;Thread Things&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;注意事項分類&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;盡量使用local primative variable, 有reference的object就不一定。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;TheadLocal Class使用方法，看例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Solution{
public static class MyRunner implements Runnable{
    private ThreadLocal&amp;lt;Double&amp;gt; localInt = new ThreadLocal&amp;lt;Double&amp;gt;();
    private double noProtect = 0.0;
    @Override
    public void run(){
        double d = Math.random();
        System.out.println(d);
        noProtect = d;
        localInt.set(d);
        try{
            Thread.sleep(1000);
        }catch(InterruptedException e){
            //nothing here now
        }
        System.out.println(localInt.get());
        System.out.println(noProtect);
    }
}
public static void go() throws Exception{
    MyRunner m1 = new MyRunner();
    Thread thread1 = new Thread(m1);
    Thread thread2 = new Thread(m1);


    thread1.start();
    thread2.start();


    thread1.join(); //wait for thread 1 to terminate
    thread2.join(); //wait for thread 2 to terminate
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;需要share的情況怎麼辦？&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;要取用大家共用的object，使用synchronized比較好（但比較慢）&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Volatile &lt;img src=&#34;http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-6.png&#34; alt=&#34;記憶體的圖&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;因為現在的電腦有多個cpu, 還有cpu-memory cache, 所以某個thread要是修改了某個variable, 要確定在每個thread都看到的話，就需要volatile這個關鍵字&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;multi-thread的volatile必須synchronized, 不然就race condition了&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Thread 控制:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Object的&lt;code&gt;notify()&lt;/code&gt;, &lt;code&gt;wait()&lt;/code&gt;, &lt;code&gt;notifyAll()&lt;/code&gt;, 與另外一個什麼我現在忘了..&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Signaling via Shared Objects: 若B thread要等A thread做完某事，才能接手，此刻，他們需要共同reference一個object, 然後set這個object的value，讓另外一個thread看，另外一個thread要polling這個variable, 此為busy wait。&lt;/li&gt;
&lt;li&gt;wait and notify, example: （必須使用synchronized!!! 某thread要可以wait, notify, 必須要有該物件的lock)&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;class Q {
    int n;
    boolean valueSet = false;
    synchronized int get() {
        while(!valueSet){
            try {
                wait();
            } catch(InterruptedException e) {
                System.out.println(&amp;quot;InterruptedException caught&amp;quot;);
            }
        }
        System.out.println(&amp;quot;Got: &amp;quot; + n);
        valueSet = false;
        notify();
        return n;
    }
    synchronized void put(int n) {
        while(valueSet){
            try {
                wait();
            } catch(InterruptedException e) {
                System.out.println(&amp;quot;InterruptedException caught&amp;quot;);
            }
        }
        this.n = n;
        valueSet = true;
        System.out.println(&amp;quot;Put: &amp;quot; + n);
        notify();
    }
}
class Producer implements Runnable {
    Q q;
    Producer(Q q) {
        this.q = q;
        new Thread(this, &amp;quot;Producer&amp;quot;).start();
    }
    public void run() {
        int i = 0;
        while(true) {
            q.put(i++);
        }
    }
}
class Consumer implements Runnable {
    Q q;
    Consumer(Q q) {
        this.q = q;
        new Thread(this, &amp;quot;Consumer&amp;quot;).start();
    }
    public void run() {
        while(true) {
            q.get();
        }
    }
}
class PCFixed {
    public static void main(String args[]) {
        Q q = new Q();
        new Producer(q);
        new Consumer(q);
        System.out.println(&amp;quot;Press Control-C to stop.&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;idiom&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;synchronized (sharedObject) {
    while (condition) {
           sharedObject.wait();
           // (Releases lock, and reacquires on wakeup)
    }
    // do action based upon condition e.g. take or put into queue
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;data-structure:2fe63a086631fd317b5011f46eddfec4&#34;&gt;Data Structure&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;transient?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;oo-principle:2fe63a086631fd317b5011f46eddfec4&#34;&gt;OO principle&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;polymorphism &lt;a name=&#34;poly&#34;&gt;&lt;/a&gt;

&lt;ol&gt;
&lt;li&gt;利用父類別的型態&lt;/li&gt;
&lt;li&gt;接受子類別的物件&lt;/li&gt;
&lt;li&gt;做相同的動作&lt;/li&gt;
&lt;li&gt;引發不同的行為&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;design-pattern:2fe63a086631fd317b5011f46eddfec4&#34;&gt;Design Pattern&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Strategy&lt;/li&gt;
&lt;li&gt;Decorator&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;面經:2fe63a086631fd317b5011f46eddfec4&#34;&gt;面經&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;九种基本数据类型的大小，以及他们的封装类。

&lt;ul&gt;
&lt;li&gt;byte  1byte, 8-bits&lt;/li&gt;
&lt;li&gt;short 2bytes&lt;/li&gt;
&lt;li&gt;int   4bytes&lt;/li&gt;
&lt;li&gt;long  8bytes&lt;/li&gt;
&lt;li&gt;float 4bytes&lt;/li&gt;
&lt;li&gt;double    8bytes&lt;/li&gt;
&lt;li&gt;boolean   true/false 1 bit&lt;/li&gt;
&lt;li&gt;char  16-bit, 2bytes&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Switch能否用string做参数？

&lt;ul&gt;
&lt;li&gt;從JDK 7 之後就可以了&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;equals与==的区别。

&lt;ul&gt;
&lt;li&gt;== compare with reference, equals compare the string value&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Object有哪些公用方法？

&lt;ul&gt;
&lt;li&gt;othres:

&lt;ul&gt;
&lt;li&gt;clone() : 複製&lt;/li&gt;
&lt;li&gt;equals() : 實作物件的相等&lt;/li&gt;
&lt;li&gt;finalize() : GC要回收這個object的時候會call這個method&lt;/li&gt;
&lt;li&gt;getClass() :&lt;/li&gt;
&lt;li&gt;hashCode() :&lt;/li&gt;
&lt;li&gt;toString()&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;thread:

&lt;ul&gt;
&lt;li&gt;notify() : 把在等這個物件的thread叫醒&lt;/li&gt;
&lt;li&gt;notifyAll() : 對全部在等這個物件的thread叫醒&lt;/li&gt;
&lt;li&gt;wait() : 讓現在在用的thread睡著&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Java的四种引用(reference)，强弱软虚，用到的场景。

&lt;ul&gt;
&lt;li&gt;normal Reference : 正常物件有的reference，既然有，GC就不會回收這個物件&lt;/li&gt;
&lt;li&gt;Soft Reference :&lt;/li&gt;
&lt;li&gt;Weak Reference : 當某物件只剩下weak reference, GC會把它清掉
&lt;code&gt;
Car car = new Car(22000,&amp;quot;silver&amp;quot;);  
WeakReference&amp;lt;Car&amp;gt; weakCar = new WeakReference&amp;lt;Car&amp;gt;(car);
int i=0;  
while(true){  
    if(weakCar.get()!=null){  
        i++;  
        System.out.println(&amp;quot;Object is alive for &amp;quot;+i+&amp;quot; loops - &amp;quot;+weakCar);  
    }else{  
        System.out.println(&amp;quot;Object has been collected.&amp;quot;);  
        break;  
    }  
}  
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Phantom Reference&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Hashcode的作用

&lt;ul&gt;
&lt;li&gt;在使用collector的時候，如Set, 要保證放進Set的物件不重複，必須調用這個method, 理論上這個method每個物件出來的value要不同&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ArrayList、LinkedList、Vector的区别。

&lt;ul&gt;
&lt;li&gt;List : is an ordered sequence of elements&lt;/li&gt;
&lt;li&gt;ArrayList : list implemented with resizable array.&lt;/li&gt;
&lt;li&gt;LinkedList : list implemented with double linked list. better add/remove time than arraylist, slower for get/set&lt;/li&gt;
&lt;li&gt;LinkedList

&lt;ul&gt;
&lt;li&gt;get is O(n)&lt;/li&gt;
&lt;li&gt;add is O(1)&lt;/li&gt;
&lt;li&gt;remove is O(n)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ArrayList

&lt;ul&gt;
&lt;li&gt;get is O(1)&lt;/li&gt;
&lt;li&gt;add is O(1), but with array resize, will be O(n)&lt;/li&gt;
&lt;li&gt;remove is O(n)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Vector:

&lt;ul&gt;
&lt;li&gt;almost arraylist, with synchronized, 對於thread safe的場景，使用arraylist會比較好&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;String、StringBuffer与StringBuilder的区别。

&lt;ul&gt;
&lt;li&gt;String: the length cannot be modified&lt;/li&gt;
&lt;li&gt;StringBuffer: faster when you want to frequently modified a String, thread-safe&lt;/li&gt;
&lt;li&gt;StringBuilder: almost the same with StringBuffer, not thread-safe&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Map、Set、List、Queue、Stack的特点与用法。

&lt;ul&gt;
&lt;li&gt;Map - key, value one-on-one mapping.&lt;/li&gt;
&lt;li&gt;Set - save non-duplicated elements, not preserve their order.&lt;/li&gt;
&lt;li&gt;List - save elements with order, the element and be duplicated.&lt;/li&gt;
&lt;li&gt;Queue - interface with offer, poll, peak. ArrayList is one of implementation.&lt;/li&gt;
&lt;li&gt;Stack - based on Vector, implement First In Last Out fashion.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;HashMap和HashTable的区别。

&lt;ul&gt;
&lt;li&gt;They are Map interface implementation.&lt;/li&gt;
&lt;li&gt;HashTable : thread-safe, cannot store null&lt;/li&gt;
&lt;li&gt;HashMap : non- threadsafe, can store null&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;HashMap和ConcurrentHashMap的区别，HashMap的底层源码。&lt;/li&gt;
&lt;li&gt;TreeMap、HashMap、LindedHashMap的区别。&lt;/li&gt;
&lt;li&gt;Collection包结构，与Collections的区别。&lt;/li&gt;
&lt;li&gt;try catch finally，try里有return，finally还执行么？&lt;/li&gt;
&lt;li&gt;Excption与Error包结构。OOM你遇到过哪些情况，SOF你遇到过哪些情况。 -&amp;gt; 太偏&lt;/li&gt;
&lt;li&gt;Java面向对象的三个特征与含义。&lt;/li&gt;
&lt;li&gt;Override和Overload的含义去区别。

&lt;ul&gt;
&lt;li&gt;override: sub class extend super class&amp;rsquo;s function(change behavior or specify task)&lt;/li&gt;
&lt;li&gt;overload: member functions may have the same name if there parameters are different.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Interface与abstract class的区别。

&lt;ul&gt;
&lt;li&gt;interface:&lt;/li&gt;
&lt;li&gt;abstract class:&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Static class 与non static class的区别。&lt;/li&gt;
&lt;li&gt;java多态的实现原理。 請見&lt;a href=&#34;#poly&#34;&gt;上面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;实现多线程的两种方法：Thread与Runable。&lt;/li&gt;
&lt;li&gt;线程同步的方法：sychronized、lock、reentrantLock等。&lt;/li&gt;
&lt;li&gt;锁的等级：方法锁、对象锁、类锁。&lt;/li&gt;
&lt;li&gt;写出生产者消费者模式。&lt;/li&gt;
&lt;li&gt;ThreadLocal的设计理念与作用。&lt;/li&gt;
&lt;li&gt;ThreadPool用法与优势。&lt;/li&gt;
&lt;li&gt;Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等。&lt;/li&gt;
&lt;li&gt;wait()和sleep()的区别。&lt;/li&gt;
&lt;li&gt;foreach与正常for循环效率对比。&lt;/li&gt;
&lt;li&gt;Java IO与NIO。&lt;/li&gt;
&lt;li&gt;反射的作用于原理。&lt;/li&gt;
&lt;li&gt;泛型常用特点，List&lt;String&gt;能否转为List&lt;Object&gt;。&lt;/li&gt;
&lt;li&gt;解析XML的几种方式的原理与特点：DOM、SAX、PULL。&lt;/li&gt;
&lt;li&gt;Java与C++对比。&lt;/li&gt;
&lt;li&gt;Java1.7与1.8新特性。&lt;/li&gt;
&lt;li&gt;设计模式：单例、工厂、适配器、责任链、观察者等等。&lt;/li&gt;
&lt;li&gt;JNI的使用。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;JVM
1. 内存模型以及分区，需要详细到每个区放什么。
2. 堆里面的分区：Eden，survival from to，老年代，各自的特点。
3. 对象创建方法，对象的内存分配，对象的访问定位。
4. GC的两种判定方法：引用计数与引用链。
5. GC的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？
6. GC收集器有哪些？CMS收集器与G1收集器的特点。
7. Minor GC与Full GC分别在什么时候发生？
8. 几种常用的内存调试工具：jmap、jstack、jconsole。
9. 类加载的五个过程：加载、验证、准备、解析、初始化。
10. 双亲委派模型：Bootstrap ClassLoader、Extension ClassLoader、ApplicationClassLoader。
11. 分派：静态分派与动态分派。
JVM过去过来就问了这么些问题，没怎么变，内存模型和GC算法这块问得比较多，可以在网上多找几篇博客来看看。
推荐书籍：《深入理解java虚拟机》&lt;/p&gt;

&lt;p&gt;操作系统
1. 进程和线程的区别。
2. 死锁的必要条件，怎么处理死锁。
3. Window内存管理方式：段存储，页存储，段页存储。
4. 进程的几种状态。
5. IPC几种通信方式。
6. 什么是虚拟内存。
7. 虚拟地址、逻辑地址、线性地址、物理地址的区别。
因为是做android的这一块问得比较少一点，还有可能上我简历上没有写操作系统的原因。
推荐书籍：《深入理解现代操作系统》&lt;/p&gt;

&lt;p&gt;TCP/IP
1. OSI与TCP/IP各层的结构与功能，都有哪些协议。
2. TCP与UDP的区别。
3. TCP报文结构。
4. TCP的三次握手与四次挥手过程，各个状态名称与含义，TIMEWAIT的作用。
5. TCP拥塞控制。
6. TCP滑动窗口与回退N针协议。
7. Http的报文结构。
8. Http的状态码含义。
9. Http request的几种类型。
10. Http1.1和Http1.0的区别
11. Http怎么处理长连接。
12. Cookie与Session的作用于原理。
13. 电脑上访问一个网页，整个过程是怎么样的：DNS、HTTP、TCP、OSPF、IP、ARP。
14. Ping的整个过程。ICMP报文是什么。
15. C/S模式下使用socket通信，几个关键函数。
16. IP地址分类。
17. 路由器与交换机区别。&lt;/p&gt;

&lt;p&gt;网络其实大体分为两块，一个TCP协议，一个HTTP协议，只要把这两块以及相关协议搞清楚，一般问题不大。
推荐书籍：《TCP/IP协议族》&lt;/p&gt;

&lt;p&gt;数据结构与算法
1. 链表与数组。
2. 队列和栈，出栈与入栈。
3. 链表的删除、插入、反向。
4. 字符串操作。
5. Hash表的hash函数，冲突解决方法有哪些。
6. 各种排序：冒泡、选择、插入、希尔、归并、快排、堆排、桶排、基数的原理、平均时间复杂度、最坏时间复杂度、空间复杂度、是否稳定。
7. 快排的partition函数与归并的Merge函数。
8. 对冒泡与快排的改进。
9. 二分查找，与变种二分查找。
10. 二叉树、B+树、AVL树、红黑树、哈夫曼树。
11. 二叉树的前中后续遍历：递归与非递归写法，层序遍历算法。
12. 图的BFS与DFS算法，最小生成树prim算法与最短路径Dijkstra算法。
13. KMP算法。
14. 排列组合问题。
15. 动态规划、贪心算法、分治算法。（一般不会问到）
16. 大数据处理：类似10亿条数据找出最大的1000个数&amp;hellip;&amp;hellip;&amp;hellip;等等
算法的话其实是个重点，因为最后都是要你写代码，所以算法还是需要花不少时间准备，这里有太多算法题，写不全，我的建议是没事多在OJ上刷刷题（牛客网、leetcode等），剑指offer上的算法要能理解并自己写出来，编程之美也推荐看一看。
推荐书籍：《大话数据结构》《剑指offer》《编程之美》&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>react與js的各種小知識</title>
      <link>https://dixentw.github.io/s/page/react/</link>
      <pubDate>Wed, 04 May 2016 10:15:22 +0800</pubDate>
      
      <guid>https://dixentw.github.io/s/page/react/</guid>
      <description>&lt;p&gt;&lt;strong&gt;React&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://eddychang.me/blog/javascript/78-react-style-guide-zhtw.html&#34;&gt;React Style Guild 中文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://camjackson.net/post/9-things-every-reactjs-beginner-should-know&#34;&gt;Tips for beginner&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://rhadow.github.io/2015/07/30/beginner-redux/&#34;&gt;redux入門&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://redux.js.org&#34;&gt;redux官方文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://dosudo.com/2015/10/18/react-生態系介紹-by-mr-friday/&#34;&gt;react生態系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mattermost/platform&#34;&gt;可以研讀的project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.formidable.com/react-inline-styles-and-the-future-of-css-cbc85e74bc42#.ecp8k6uck&#34;&gt;inline style&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Javascript&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://pofolio.cc/2015/03/09/javascript-how-to-promise-well/&#34;&gt;Promise well&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://fred-zone.blogspot.tw/2015/05/javascript.html&#34;&gt;js fog迷霧啊～～&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch2.html&#34;&gt;寫得不錯的javascript functional 指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://es6.ruanyifeng.com/#docs/async&#34;&gt;ES6&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Front-End&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://frontendmasters.gitbooks.io/front-end-handbook/content/practice/types-of-front-end-dev.html&#34;&gt;front-end handbook&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/zhbhun/article/details/47208885&#34;&gt;webpack學習筆記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.restapitutorial.com/lessons/restquicktips.html&#34;&gt;rest api 指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://ww12.f2eclass.com&#34;&gt;front-end課程&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;MISC&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.hackingwithswift.com/read/31/overview&#34;&gt;IOS pratices&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://marc.helbling.fr/2014/09/practical-git-introduction&#34;&gt;GIT Pratical Guide &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.alexkras.com/19-git-tips-for-everyday-use/&#34;&gt;every day git tips&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Nexusguard Settings</title>
      <link>https://dixentw.github.io/s/page/nxgsetting/</link>
      <pubDate>Fri, 29 Apr 2016 17:49:51 +0800</pubDate>
      
      <guid>https://dixentw.github.io/s/page/nxgsetting/</guid>
      <description>&lt;p&gt;&lt;strong&gt;把有常回來找的東西貼在這裡:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;常用指令：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;LDAP密碼:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;最複雜的那個Csxxxx)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://serversforhackers.com/video/process-monitoring-with-upstart&#34;&gt;Upstart reference&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Nexusguard Project TODO</title>
      <link>https://dixentw.github.io/s/page/todonxg/</link>
      <pubDate>Fri, 29 Apr 2016 11:31:05 +0800</pubDate>
      
      <guid>https://dixentw.github.io/s/page/todonxg/</guid>
      <description>&lt;p&gt;Few things to do here.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Platform improvement&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;google cluster的etcd? 想知道寫入速度有多快可以sync&lt;/li&gt;
&lt;li&gt;ssdb client reconnect 加強？How?&lt;/li&gt;
&lt;li&gt;SSDB sync 還要走嗎？&lt;/li&gt;
&lt;li&gt;G-Center Monitor refactor到不會crash, 可以一直看？&lt;/li&gt;
&lt;li&gt;redis go client replace ssdb client?

&lt;ul&gt;
&lt;li&gt;已經沒有reconnect的功能了&amp;hellip;&lt;/li&gt;
&lt;li&gt;zeromq可以解這個問題嗎？&lt;/li&gt;
&lt;li&gt;DF 4003可以通 :) , sadly TD, DPI 4003不行&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;DNS project&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;User ACL: need to do?

&lt;ol&gt;
&lt;li&gt;Add new permission:AdminReadOnly&lt;/li&gt;
&lt;li&gt;Add new permission:AdminManager -&amp;gt; 開一個帳號，如果是這種User, 不要load zone file, 只給他管帳號的功能就好了&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;OP project&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;op panel refactor

&lt;ul&gt;
&lt;li&gt;$resource, model translation&lt;/li&gt;
&lt;li&gt;chart section code&lt;/li&gt;
&lt;li&gt;canvas chart (improvement)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Job Related</title>
      <link>https://dixentw.github.io/s/page/job_related/</link>
      <pubDate>Thu, 28 Apr 2016 10:24:06 +0800</pubDate>
      
      <guid>https://dixentw.github.io/s/page/job_related/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Interview&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gist.github.com/hanksudo/5873678&#34;&gt;前端工程師問題集&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.interviewcake.com/article/python/coding-interview-tips&#34;&gt;coding interview tips&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=qlUhDbJ_zGo&#34;&gt;google 面試題講解vedio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://softnshare.wordpress.com/2016/02/21/程式語言面試考題集錦/&#34;&gt;各種程式語言面試&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.hiredintech.com/system-design&#34;&gt;System Desgin&lt;/a&gt;，本site還有其他的題目可以看一下&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ptt.cc/bbs/Oversea_Job/M.1461635151.A.466.html&#34;&gt;真好文, from ptt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.1point3acres.com/bbs/&#34;&gt;一畝三分地&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://e-jelly.blogspot.tw/2016/01/blog-post.html?view=classic&#34;&gt;日常練習&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;程式語言的實作 - amazon北京&lt;/li&gt;
&lt;li&gt;資料結構/基礎演算法 - 365.com, amazon&lt;/li&gt;
&lt;li&gt;leetcode解題 - almost every company&lt;/li&gt;
&lt;li&gt;系統設計 - spotify, 365.com&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.mitbbs.com/article_t1/JobHunting/32777529_0_1.html&#34;&gt;牛人的System desgin 總結&lt;/a&gt;
&lt;strong&gt;leetcode的blog, 參考一下人家的寫法&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://leetcodenotes.wordpress.com/page/11/&#34;&gt;第一個&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/u011095253/article/details/9158397&#34;&gt;第二個&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/grandyang/p/4606334.html&#34;&gt;第三個&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Soft Skill&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.freecodecamp.com/how-to-level-up-as-a-developer-87344584777c#.3ryrrixfm&#34;&gt;How to level up as developer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.inside.com.tw/2016/02/24/studying-after-work&#34;&gt;自學（有幾堂課不錯）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@akosma/being-a-developer-after-40-3c5dd112210c#.7mftr0iu7&#34;&gt;生涯指導&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Job site to find remote work&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://webwork.io&#34;&gt;webwork&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kaizensoze/remote-freelance-jobs&#34;&gt;remote freelencer job&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.freelancerejobs.com&#34;&gt;freelancerejobs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://skillcrush.com/2014/10/10/sites-finding-remote-work/&#34;&gt;best 25 sites&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Angular的各種小知識</title>
      <link>https://dixentw.github.io/s/page/angular/</link>
      <pubDate>Wed, 27 Apr 2016 23:03:11 +0800</pubDate>
      
      <guid>https://dixentw.github.io/s/page/angular/</guid>
      <description>&lt;p&gt;直接上link, 有些還沒實作完畢~&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://amobiz.github.io/2016/04/15/angularjs-1.5-best-practices/&#34;&gt;angular 實務作法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@bluepnume/sane-scalable-angular-apps-are-tricky-but-not-impossible-lessons-learned-from-paypal-checkout-c5320558d4ef#.60rwxb98r&#34;&gt;前面一項的原文版，他翻譯過來再加自己的見解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://roxannera.blogspot.tw/2014/01/angularjs-service-factory-provider.html&#34;&gt;factory, service, provider 的差別&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/angularjs/dependency-injection.html#injecting-values-into-a-factory&#34;&gt;dependency injection&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://toddmotto.com/rethinking-angular-js-controllers/&#34;&gt;rethink controller as model&lt;/a&gt; ：好像有點有趣，有時間可以先讀！&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.webdeveasy.com/angularjs-data-model/&#34;&gt;建立好Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@hackupstate/improving-angular-performance-with-1-line-of-code-a1fb814a6476#.os6hz3w1h&#34;&gt;https://medium.com/@hackupstate/improving-angular-performance-with-1-line-of-code-a1fb814a6476#.os6hz3w1h&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Golang的各種不錯知識</title>
      <link>https://dixentw.github.io/s/page/golang/</link>
      <pubDate>Wed, 27 Apr 2016 22:49:17 +0800</pubDate>
      
      <guid>https://dixentw.github.io/s/page/golang/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Golang的點點滴滴&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://brandonokert.com/2016/04/18/Json-Management-Patterns-In-Go/?utm_source=golangweekly&amp;amp;utm_medium=email#Easy_Validation&#34;&gt;Json 處理pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/buger/jsonparser&#34;&gt;快速json parser, API感覺比原生好用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.brnstz.com/post/143049621938/the-most-seductive-keyword&#34;&gt;concurrent code的演化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://crosbymichael.com/category/go.html&#34;&gt;Docker用的dynamic plugin&lt;/a&gt; -&amp;gt; 應該算是適合aggregator在使用（使用go 弄出javascript的execute env, 把核心算法寫在script裡面，就可以做到動態安插新的算法&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.fknsrs.biz/blog/otto-getting-started.html?utm_source=golangweekly&amp;amp;utm_medium=email&#34;&gt;承上，otta的介紹&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://peter.bourgon.org/go-best-practices-2016/?utm_source=golangweekly&amp;amp;utm_medium=email&#34;&gt;Go best practice&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://elithrar.github.io/article/testing-http-handlers-go/?utm_source=golangweekly&amp;amp;utm_medium=email&#34;&gt;Restful API testing in Golang&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@gianbiondi/interfaces-in-go-59c3dc9c2d98#.en5j77rk3&#34;&gt;Interface Example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/mitchellh/advanced-testing-with-go?utm_source=golangweekly&amp;amp;utm_medium=email&#34;&gt;Test Fixture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.twilio.com/blog/2016/02/how-alan-shreve-built-ngrok-with-go.html&#34;&gt;ngrok的演講&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jannewmarch.gitbooks.io/network-programming-with-go-golang-/content/&#34;&gt;git book : network programming in GO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://divan.github.io/posts/go_concurrency_visualize/&#34;&gt;go concurrent visualization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.golangpatterns.info/object-oriented/constructors&#34;&gt;go other pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cepave.com/go-package-vendoring/&#34;&gt;go dependency management&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html#closed_ch_send&#34;&gt;50 shades of golang&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://javax0.wordpress.com/2016/04/27/comparing-golang-with-java/?utm_source=golangweekly&amp;amp;utm_medium=email&#34;&gt;Golang與Java的深度比較，不是很懂日後再看&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>