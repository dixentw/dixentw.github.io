<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>工作日誌</title>
    <link>https://dixentw.github.io/s/</link>
    <description>Recent content on 工作日誌</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 09 May 2016 11:20:30 +0800</lastBuildDate>
    <atom:link href="https://dixentw.github.io/s/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>rectangle</title>
      <link>https://dixentw.github.io/s/leetcode/rectangle/</link>
      <pubDate>Mon, 09 May 2016 11:20:30 +0800</pubDate>
      
      <guid>https://dixentw.github.io/s/leetcode/rectangle/</guid>
      <description>&lt;p&gt;Find the total area covered by two rectilinear rectangles in a 2D plane.&lt;/p&gt;

&lt;p&gt;Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://leetcode.com/static/images/problemset/rectangle_area.png&#34; alt=&#34;Rectangle Area&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Assume that the total area is never beyond the maximum possible value of int.&lt;/p&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li&gt;判斷兩個矩形是否

&lt;ol&gt;
&lt;li&gt;分開&lt;/li&gt;
&lt;li&gt;包含&lt;/li&gt;
&lt;li&gt;交集&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;初始想法：交集有分四種交集法，左上交集，左下交集，右上交集，右下交集
所以這判斷式太多，我們需要general的方法判斷交集矩形的上下左右&lt;/p&gt;

&lt;p&gt;如下程式碼是別人的，包含與交集可以一起判斷&lt;/p&gt;

&lt;p&gt;This problem can be converted as a overlap internal problem. On the x-axis, there are (A,C) and (E,G); on the y-axis, there are (F,H) and (B,D). If they do not have overlap, the total area is the sum of 2 rectangle areas. If they have overlap, the total area should minus the overlap area.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.programcreek.com/wp-content/uploads/2015/06/rectangle-area-400x187.jpg&#34; alt=&#34;圖示&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {
   //if R1, R2 overlap, contains, or separate?
    //1. seperate :
    if(E&amp;gt;=C ||F&amp;gt;=D){
        return (C-A)*(D-B) + (G-E)*(H-F);
    }
    if(A&amp;gt;=G ||B&amp;gt;=H){
        return (C-A)*(D-B) + (G-E)*(H-F);
    }
    //2. contains or overlap:
    int right = Math.min(C, G);
    int left = Math.max(A, E);
    int top = Math.min(H, D);
    int bottom = Math.max(B, F);
    return (C-A)*(D-B)+(G-E)*(H-F) - (right-left) * (top-bottom);
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>java各種小知識</title>
      <link>https://dixentw.github.io/s/page/java/</link>
      <pubDate>Sat, 07 May 2016 15:28:03 +0800</pubDate>
      
      <guid>https://dixentw.github.io/s/page/java/</guid>
      <description>

&lt;h3 id=&#34;garbage-collection:2fe63a086631fd317b5011f46eddfec4&#34;&gt;Garbage collection&lt;/h3&gt;

&lt;h3 id=&#34;thread-things:2fe63a086631fd317b5011f46eddfec4&#34;&gt;Thread Things&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;注意事項分類&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;盡量使用local primative variable, 有reference的object就不一定。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;TheadLocal Class使用方法，看例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Solution{
public static class MyRunner implements Runnable{
    private ThreadLocal&amp;lt;Double&amp;gt; localInt = new ThreadLocal&amp;lt;Double&amp;gt;();
    private double noProtect = 0.0;
    @Override
    public void run(){
        double d = Math.random();
        System.out.println(d);
        noProtect = d;
        localInt.set(d);
        try{
            Thread.sleep(1000);
        }catch(InterruptedException e){
            //nothing here now
        }
        System.out.println(localInt.get());
        System.out.println(noProtect);
    }
}
public static void go() throws Exception{
    MyRunner m1 = new MyRunner();
    Thread thread1 = new Thread(m1);
    Thread thread2 = new Thread(m1);


    thread1.start();
    thread2.start();


    thread1.join(); //wait for thread 1 to terminate
    thread2.join(); //wait for thread 2 to terminate
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;需要share的情況怎麼辦？&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;要取用大家共用的object，使用synchronized比較好（但比較慢）&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Volatile &lt;img src=&#34;http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-6.png&#34; alt=&#34;記憶體的圖&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;因為現在的電腦有多個cpu, 還有cpu-memory cache, 所以某個thread要是修改了某個variable, 要確定在每個thread都看到的話，就需要volatile這個關鍵字&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;multi-thread的volatile必須synchronized, 不然就race condition了&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Thread 控制:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Object的&lt;code&gt;notify()&lt;/code&gt;, &lt;code&gt;wait()&lt;/code&gt;, &lt;code&gt;notifyAll()&lt;/code&gt;, 與另外一個什麼我現在忘了..&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Signaling via Shared Objects: 若B thread要等A thread做完某事，才能接手，此刻，他們需要共同reference一個object, 然後set這個object的value，讓另外一個thread看，另外一個thread要polling這個variable, 此為busy wait。&lt;/li&gt;
&lt;li&gt;wait and notify, example: （必須使用synchronized!!! 某thread要可以wait, notify, 必須要有該物件的lock)&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;class Q {
    int n;
    boolean valueSet = false;
    synchronized int get() {
        while(!valueSet){
            try {
                wait();
            } catch(InterruptedException e) {
                System.out.println(&amp;quot;InterruptedException caught&amp;quot;);
            }
        }
        System.out.println(&amp;quot;Got: &amp;quot; + n);
        valueSet = false;
        notify();
        return n;
    }
    synchronized void put(int n) {
        while(valueSet){
            try {
                wait();
            } catch(InterruptedException e) {
                System.out.println(&amp;quot;InterruptedException caught&amp;quot;);
            }
        }
        this.n = n;
        valueSet = true;
        System.out.println(&amp;quot;Put: &amp;quot; + n);
        notify();
    }
}
class Producer implements Runnable {
    Q q;
    Producer(Q q) {
        this.q = q;
        new Thread(this, &amp;quot;Producer&amp;quot;).start();
    }
    public void run() {
        int i = 0;
        while(true) {
            q.put(i++);
        }
    }
}
class Consumer implements Runnable {
    Q q;
    Consumer(Q q) {
        this.q = q;
        new Thread(this, &amp;quot;Consumer&amp;quot;).start();
    }
    public void run() {
        while(true) {
            q.get();
        }
    }
}
class PCFixed {
    public static void main(String args[]) {
        Q q = new Q();
        new Producer(q);
        new Consumer(q);
        System.out.println(&amp;quot;Press Control-C to stop.&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;idiom&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;synchronized (sharedObject) {
    while (condition) {
           sharedObject.wait();
           // (Releases lock, and reacquires on wakeup)
    }
    // do action based upon condition e.g. take or put into queue
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;data-structure:2fe63a086631fd317b5011f46eddfec4&#34;&gt;Data Structure&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;transient?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;oo-principle:2fe63a086631fd317b5011f46eddfec4&#34;&gt;OO principle&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;polymorphism &lt;a name=&#34;poly&#34;&gt;&lt;/a&gt;

&lt;ol&gt;
&lt;li&gt;利用父類別的型態&lt;/li&gt;
&lt;li&gt;接受子類別的物件&lt;/li&gt;
&lt;li&gt;做相同的動作&lt;/li&gt;
&lt;li&gt;引發不同的行為&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;design-pattern:2fe63a086631fd317b5011f46eddfec4&#34;&gt;Design Pattern&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Strategy&lt;/li&gt;
&lt;li&gt;Decorator&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;面經:2fe63a086631fd317b5011f46eddfec4&#34;&gt;面經&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;九种基本数据类型的大小，以及他们的封装类。

&lt;ul&gt;
&lt;li&gt;byte  1byte, 8-bits&lt;/li&gt;
&lt;li&gt;short 2bytes&lt;/li&gt;
&lt;li&gt;int   4bytes&lt;/li&gt;
&lt;li&gt;long  8bytes&lt;/li&gt;
&lt;li&gt;float 4bytes&lt;/li&gt;
&lt;li&gt;double    8bytes&lt;/li&gt;
&lt;li&gt;boolean   true/false 1 bit&lt;/li&gt;
&lt;li&gt;char  16-bit, 2bytes&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Switch能否用string做参数？

&lt;ul&gt;
&lt;li&gt;從JDK 7 之後就可以了&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;equals与==的区别。

&lt;ul&gt;
&lt;li&gt;== compare with reference, equals compare the string value&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Object有哪些公用方法？

&lt;ul&gt;
&lt;li&gt;othres:

&lt;ul&gt;
&lt;li&gt;clone() : 複製&lt;/li&gt;
&lt;li&gt;equals() : 實作物件的相等&lt;/li&gt;
&lt;li&gt;finalize() : GC要回收這個object的時候會call這個method&lt;/li&gt;
&lt;li&gt;getClass() :&lt;/li&gt;
&lt;li&gt;hashCode() :&lt;/li&gt;
&lt;li&gt;toString()&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;thread:

&lt;ul&gt;
&lt;li&gt;notify() : 把在等這個物件的thread叫醒&lt;/li&gt;
&lt;li&gt;notifyAll() : 對全部在等這個物件的thread叫醒&lt;/li&gt;
&lt;li&gt;wait() : 讓現在在用的thread睡著&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Java的四种引用(reference)，强弱软虚，用到的场景。

&lt;ul&gt;
&lt;li&gt;normal Reference : 正常物件有的reference，既然有，GC就不會回收這個物件&lt;/li&gt;
&lt;li&gt;Soft Reference :&lt;/li&gt;
&lt;li&gt;Weak Reference : 當某物件只剩下weak reference, GC會把它清掉
&lt;code&gt;
Car car = new Car(22000,&amp;quot;silver&amp;quot;);  
WeakReference&amp;lt;Car&amp;gt; weakCar = new WeakReference&amp;lt;Car&amp;gt;(car);
int i=0;  
while(true){  
    if(weakCar.get()!=null){  
        i++;  
        System.out.println(&amp;quot;Object is alive for &amp;quot;+i+&amp;quot; loops - &amp;quot;+weakCar);  
    }else{  
        System.out.println(&amp;quot;Object has been collected.&amp;quot;);  
        break;  
    }  
}  
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Phantom Reference&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Hashcode的作用

&lt;ul&gt;
&lt;li&gt;在使用collector的時候，如Set, 要保證放進Set的物件不重複，必須調用這個method, 理論上這個method每個物件出來的value要不同&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ArrayList、LinkedList、Vector的区别。

&lt;ul&gt;
&lt;li&gt;List : is an ordered sequence of elements&lt;/li&gt;
&lt;li&gt;ArrayList : list implemented with resizable array.&lt;/li&gt;
&lt;li&gt;LinkedList : list implemented with double linked list. better add/remove time than arraylist, slower for get/set&lt;/li&gt;
&lt;li&gt;LinkedList

&lt;ul&gt;
&lt;li&gt;get is O(n)&lt;/li&gt;
&lt;li&gt;add is O(1)&lt;/li&gt;
&lt;li&gt;remove is O(n)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ArrayList

&lt;ul&gt;
&lt;li&gt;get is O(1)&lt;/li&gt;
&lt;li&gt;add is O(1), but with array resize, will be O(n)&lt;/li&gt;
&lt;li&gt;remove is O(n)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Vector:

&lt;ul&gt;
&lt;li&gt;almost arraylist, with synchronized, 對於thread safe的場景，使用arraylist會比較好&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;String、StringBuffer与StringBuilder的区别。

&lt;ul&gt;
&lt;li&gt;String: the length cannot be modified&lt;/li&gt;
&lt;li&gt;StringBuffer: faster when you want to frequently modified a String, thread-safe&lt;/li&gt;
&lt;li&gt;StringBuilder: almost the same with StringBuffer, not thread-safe&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Map、Set、List、Queue、Stack的特点与用法。

&lt;ul&gt;
&lt;li&gt;Map - key, value one-on-one mapping.&lt;/li&gt;
&lt;li&gt;Set - save non-duplicated elements, not preserve their order.&lt;/li&gt;
&lt;li&gt;List - save elements with order, the element and be duplicated.&lt;/li&gt;
&lt;li&gt;Queue - interface with offer, poll, peak. ArrayList is one of implementation.&lt;/li&gt;
&lt;li&gt;Stack - based on Vector, implement First In Last Out fashion.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;HashMap和HashTable的区别。

&lt;ul&gt;
&lt;li&gt;They are Map interface implementation.&lt;/li&gt;
&lt;li&gt;HashTable : thread-safe, cannot store null&lt;/li&gt;
&lt;li&gt;HashMap : non- threadsafe, can store null&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;HashMap和ConcurrentHashMap的区别，HashMap的底层源码。&lt;/li&gt;
&lt;li&gt;TreeMap、HashMap、LindedHashMap的区别。&lt;/li&gt;
&lt;li&gt;Collection包结构，与Collections的区别。&lt;/li&gt;
&lt;li&gt;try catch finally，try里有return，finally还执行么？&lt;/li&gt;
&lt;li&gt;Excption与Error包结构。OOM你遇到过哪些情况，SOF你遇到过哪些情况。 -&amp;gt; 太偏&lt;/li&gt;
&lt;li&gt;Java面向对象的三个特征与含义。&lt;/li&gt;
&lt;li&gt;Override和Overload的含义去区别。

&lt;ul&gt;
&lt;li&gt;override: sub class extend super class&amp;rsquo;s function(change behavior or specify task)&lt;/li&gt;
&lt;li&gt;overload: member functions may have the same name if there parameters are different.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Interface与abstract class的区别。

&lt;ul&gt;
&lt;li&gt;interface:&lt;/li&gt;
&lt;li&gt;abstract class:&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Static class 与non static class的区别。&lt;/li&gt;
&lt;li&gt;java多态的实现原理。 請見&lt;a href=&#34;#poly&#34;&gt;上面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;实现多线程的两种方法：Thread与Runable。&lt;/li&gt;
&lt;li&gt;线程同步的方法：sychronized、lock、reentrantLock等。&lt;/li&gt;
&lt;li&gt;锁的等级：方法锁、对象锁、类锁。&lt;/li&gt;
&lt;li&gt;写出生产者消费者模式。&lt;/li&gt;
&lt;li&gt;ThreadLocal的设计理念与作用。&lt;/li&gt;
&lt;li&gt;ThreadPool用法与优势。&lt;/li&gt;
&lt;li&gt;Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等。&lt;/li&gt;
&lt;li&gt;wait()和sleep()的区别。&lt;/li&gt;
&lt;li&gt;foreach与正常for循环效率对比。&lt;/li&gt;
&lt;li&gt;Java IO与NIO。&lt;/li&gt;
&lt;li&gt;反射的作用于原理。&lt;/li&gt;
&lt;li&gt;泛型常用特点，List&lt;String&gt;能否转为List&lt;Object&gt;。&lt;/li&gt;
&lt;li&gt;解析XML的几种方式的原理与特点：DOM、SAX、PULL。&lt;/li&gt;
&lt;li&gt;Java与C++对比。&lt;/li&gt;
&lt;li&gt;Java1.7与1.8新特性。&lt;/li&gt;
&lt;li&gt;设计模式：单例、工厂、适配器、责任链、观察者等等。&lt;/li&gt;
&lt;li&gt;JNI的使用。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;JVM
1. 内存模型以及分区，需要详细到每个区放什么。
2. 堆里面的分区：Eden，survival from to，老年代，各自的特点。
3. 对象创建方法，对象的内存分配，对象的访问定位。
4. GC的两种判定方法：引用计数与引用链。
5. GC的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？
6. GC收集器有哪些？CMS收集器与G1收集器的特点。
7. Minor GC与Full GC分别在什么时候发生？
8. 几种常用的内存调试工具：jmap、jstack、jconsole。
9. 类加载的五个过程：加载、验证、准备、解析、初始化。
10. 双亲委派模型：Bootstrap ClassLoader、Extension ClassLoader、ApplicationClassLoader。
11. 分派：静态分派与动态分派。
JVM过去过来就问了这么些问题，没怎么变，内存模型和GC算法这块问得比较多，可以在网上多找几篇博客来看看。
推荐书籍：《深入理解java虚拟机》&lt;/p&gt;

&lt;p&gt;操作系统
1. 进程和线程的区别。
2. 死锁的必要条件，怎么处理死锁。
3. Window内存管理方式：段存储，页存储，段页存储。
4. 进程的几种状态。
5. IPC几种通信方式。
6. 什么是虚拟内存。
7. 虚拟地址、逻辑地址、线性地址、物理地址的区别。
因为是做android的这一块问得比较少一点，还有可能上我简历上没有写操作系统的原因。
推荐书籍：《深入理解现代操作系统》&lt;/p&gt;

&lt;p&gt;TCP/IP
1. OSI与TCP/IP各层的结构与功能，都有哪些协议。
2. TCP与UDP的区别。
3. TCP报文结构。
4. TCP的三次握手与四次挥手过程，各个状态名称与含义，TIMEWAIT的作用。
5. TCP拥塞控制。
6. TCP滑动窗口与回退N针协议。
7. Http的报文结构。
8. Http的状态码含义。
9. Http request的几种类型。
10. Http1.1和Http1.0的区别
11. Http怎么处理长连接。
12. Cookie与Session的作用于原理。
13. 电脑上访问一个网页，整个过程是怎么样的：DNS、HTTP、TCP、OSPF、IP、ARP。
14. Ping的整个过程。ICMP报文是什么。
15. C/S模式下使用socket通信，几个关键函数。
16. IP地址分类。
17. 路由器与交换机区别。&lt;/p&gt;

&lt;p&gt;网络其实大体分为两块，一个TCP协议，一个HTTP协议，只要把这两块以及相关协议搞清楚，一般问题不大。
推荐书籍：《TCP/IP协议族》&lt;/p&gt;

&lt;p&gt;数据结构与算法
1. 链表与数组。
2. 队列和栈，出栈与入栈。
3. 链表的删除、插入、反向。
4. 字符串操作。
5. Hash表的hash函数，冲突解决方法有哪些。
6. 各种排序：冒泡、选择、插入、希尔、归并、快排、堆排、桶排、基数的原理、平均时间复杂度、最坏时间复杂度、空间复杂度、是否稳定。
7. 快排的partition函数与归并的Merge函数。
8. 对冒泡与快排的改进。
9. 二分查找，与变种二分查找。
10. 二叉树、B+树、AVL树、红黑树、哈夫曼树。
11. 二叉树的前中后续遍历：递归与非递归写法，层序遍历算法。
12. 图的BFS与DFS算法，最小生成树prim算法与最短路径Dijkstra算法。
13. KMP算法。
14. 排列组合问题。
15. 动态规划、贪心算法、分治算法。（一般不会问到）
16. 大数据处理：类似10亿条数据找出最大的1000个数&amp;hellip;&amp;hellip;&amp;hellip;等等
算法的话其实是个重点，因为最后都是要你写代码，所以算法还是需要花不少时间准备，这里有太多算法题，写不全，我的建议是没事多在OJ上刷刷题（牛客网、leetcode等），剑指offer上的算法要能理解并自己写出来，编程之美也推荐看一看。
推荐书籍：《大话数据结构》《剑指offer》《编程之美》&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>506</title>
      <link>https://dixentw.github.io/s/post/506/</link>
      <pubDate>Fri, 06 May 2016 10:44:08 +0800</pubDate>
      
      <guid>https://dixentw.github.io/s/post/506/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;SimpleRNN做不出來啊~~

&lt;ul&gt;
&lt;li&gt;acc 都是0&lt;/li&gt;
&lt;li&gt;原因：之前的設定是loss=&amp;ldquo;binary_crossentropy&amp;rdquo;, 看起來這個model只會判別0, 1。要multi-classification的話，需要把output label標成 [0,0,0,0,1,0,0,0,0] 這樣的array, array length代表所有的classes，剛剛試過980(直接把string hash成integer)，看起來效果不是很理想。accuracy只有0.181603375532&lt;/li&gt;
&lt;li&gt;Try2 : 把class 降低

&lt;ul&gt;
&lt;li&gt;副本：可以找找numpy有沒有現成的utils可以做這件事，不然就要自己手動寫了。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>505</title>
      <link>https://dixentw.github.io/s/post/505/</link>
      <pubDate>Thu, 05 May 2016 10:16:15 +0800</pubDate>
      
      <guid>https://dixentw.github.io/s/post/505/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;find a bug : OP panel, TD module

&lt;ul&gt;
&lt;li&gt;如果有關掉某些profile, 則TD模組不會產出他的stat, 意味著，在aggregator的過程裡面，會有些td的id個數會不一致，這種情況下，需要把沒有出現過的id, 寫進map裡面&lt;/li&gt;
&lt;li&gt;refactor, merge 的情況下，應該使用map，簡化迴圈。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>react與js的各種小知識</title>
      <link>https://dixentw.github.io/s/page/react/</link>
      <pubDate>Wed, 04 May 2016 10:15:22 +0800</pubDate>
      
      <guid>https://dixentw.github.io/s/page/react/</guid>
      <description>&lt;p&gt;&lt;strong&gt;React&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://eddychang.me/blog/javascript/78-react-style-guide-zhtw.html&#34;&gt;React Style Guild 中文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://camjackson.net/post/9-things-every-reactjs-beginner-should-know&#34;&gt;Tips for beginner&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://rhadow.github.io/2015/07/30/beginner-redux/&#34;&gt;redux入門&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://redux.js.org&#34;&gt;redux官方文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://dosudo.com/2015/10/18/react-生態系介紹-by-mr-friday/&#34;&gt;react生態系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mattermost/platform&#34;&gt;可以研讀的project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.formidable.com/react-inline-styles-and-the-future-of-css-cbc85e74bc42#.ecp8k6uck&#34;&gt;inline style&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Javascript&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://pofolio.cc/2015/03/09/javascript-how-to-promise-well/&#34;&gt;Promise well&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://fred-zone.blogspot.tw/2015/05/javascript.html&#34;&gt;js fog迷霧啊～～&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch2.html&#34;&gt;寫得不錯的javascript functional 指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://es6.ruanyifeng.com/#docs/async&#34;&gt;ES6&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Front-End&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://frontendmasters.gitbooks.io/front-end-handbook/content/practice/types-of-front-end-dev.html&#34;&gt;front-end handbook&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/zhbhun/article/details/47208885&#34;&gt;webpack學習筆記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.restapitutorial.com/lessons/restquicktips.html&#34;&gt;rest api 指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://ww12.f2eclass.com&#34;&gt;front-end課程&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;MISC&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.hackingwithswift.com/read/31/overview&#34;&gt;IOS pratices&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://marc.helbling.fr/2014/09/practical-git-introduction&#34;&gt;GIT Pratical Guide &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.alexkras.com/19-git-tips-for-everyday-use/&#34;&gt;every day git tips&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>504</title>
      <link>https://dixentw.github.io/s/post/504/</link>
      <pubDate>Wed, 04 May 2016 10:00:38 +0800</pubDate>
      
      <guid>https://dixentw.github.io/s/post/504/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;run keras of RNN, using default parameters, should understand &lt;code&gt;fit()&lt;/code&gt; training output means&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;POC zeromq with 4003 port and one DF&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;zeromq的麻煩地方: 因為綁定native libzmq, 所以要build的話要挑build machine來做&lt;/li&gt;
&lt;li&gt;需要jenkins了嗎&amp;hellip;.&lt;/li&gt;
&lt;li&gt;POC on dixengce:

&lt;ul&gt;
&lt;li&gt;scope: publisher 一直loop data給subscriber, sub晚點加入也沒關係，可以接收得到，值得注意的是，sub第一次啟動後，會不會漏掉第一個pub, 這是需要實驗的&lt;/li&gt;
&lt;li&gt;測試成功，看起來沒問題。但是以收1000筆速度來看好像有點慢&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>503</title>
      <link>https://dixentw.github.io/s/post/503/</link>
      <pubDate>Tue, 03 May 2016 11:25:55 +0800</pubDate>
      
      <guid>https://dixentw.github.io/s/post/503/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Setting up keras, run on Theano&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;先使用docker&lt;/li&gt;
&lt;li&gt;KDD99的training set還有testing set都齊了，目前工作重點在於建立RNN與LSTM的運算pipeline&lt;/li&gt;
&lt;li&gt;learning jargons, 直接讀manual太多術語不懂@@, 先看tutorial

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://neuralnetworksanddeeplearning.com&#34;&gt;原文書啊&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/u012162613/article/details/45397033&#34;&gt;Deep learning&lt;/a&gt;中文參考手冊&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Other:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;zero mq layer between SSDB with Agent?&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;OP-Panel:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CDD request : ACL filter max to 16&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>292. Nim Game</title>
      <link>https://dixentw.github.io/s/leetcode/nimgame/</link>
      <pubDate>Sat, 30 Apr 2016 09:28:52 +0800</pubDate>
      
      <guid>https://dixentw.github.io/s/leetcode/nimgame/</guid>
      <description>&lt;p&gt;You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.&lt;/p&gt;

&lt;p&gt;Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.&lt;/p&gt;

&lt;p&gt;For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.&lt;/p&gt;

&lt;p&gt;Hint:&lt;/p&gt;

&lt;p&gt;If there are 5 stones in the heap, could you figure out a way to remove the stones such that you will always be the winner?&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;是4的倍數一定輸&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public boolean canWinNim(int n) {
    if(n%4!=0){
        return true;
    }else{
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>100. Same Tree</title>
      <link>https://dixentw.github.io/s/leetcode/sametree/</link>
      <pubDate>Sat, 30 Apr 2016 09:25:21 +0800</pubDate>
      
      <guid>https://dixentw.github.io/s/leetcode/sametree/</guid>
      <description>&lt;p&gt;Given two binary trees, write a function to check if they are equal or not.&lt;/p&gt;

&lt;p&gt;Two binary trees are considered equal if they are structurally identical and the nodes have the same value.&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;遞回下去看子樹是不是一樣就好了，如果自己是leaf, 回傳true&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public boolean isSameTree(TreeNode p, TreeNode q) {
    if(p!=null &amp;amp;&amp;amp; q!=null){
        if(p.val!=q.val){
            return false;
        }else{
            return isSameTree(p.left, q.left) &amp;amp;&amp;amp; isSameTree(p.right, q.right);
        }
    }else if(p==null &amp;amp;&amp;amp; q==null){
        return true;
    }else{
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>49. Group Anagrams</title>
      <link>https://dixentw.github.io/s/leetcode/groupanagram/</link>
      <pubDate>Sat, 30 Apr 2016 09:15:42 +0800</pubDate>
      
      <guid>https://dixentw.github.io/s/leetcode/groupanagram/</guid>
      <description>&lt;p&gt;Given an array of strings, group anagrams together.&lt;/p&gt;

&lt;p&gt;For example, given: &lt;code&gt;[&amp;quot;eat&amp;quot;, &amp;quot;tea&amp;quot;, &amp;quot;tan&amp;quot;, &amp;quot;ate&amp;quot;, &amp;quot;nat&amp;quot;, &amp;quot;bat&amp;quot;]&lt;/code&gt;,
Return:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  [&amp;quot;ate&amp;quot;, &amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;],
  [&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;],
  [&amp;quot;bat&amp;quot;]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note:
For the return value, each inner list&amp;rsquo;s elements must follow the lexicographic order.
All inputs will be in lower-case.&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;解一：使用前面#242發展的演算法，用兩個index : i, j, 第一個字的時候，掃後面的字是不是anagram，一樣的就放進同一個字的arraylist, 此法一直過不了時間限制&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public static boolean isAnagram2(String s, String t){
	char[] scs = s.replaceAll(&amp;quot;\\s&amp;quot;, &amp;quot;&amp;quot;).toCharArray();
	char[] tcs = t.replaceAll(&amp;quot;\\s&amp;quot;, &amp;quot;&amp;quot;).toCharArray();
	Arrays.sort(scs);
	Arrays.sort(tcs);
	if(scs.length!=tcs.length){
		return false;
	}else{
		for(int i=0; i&amp;lt;scs.length; i++){
			if(scs[i]!=tcs[i]){
				return  false;
			}
		}
		return true;
	}
}

public List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; groupAnagrams(String[] strs) {
    List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; result = new ArrayList&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;();
	for(int i=0; i&amp;lt;strs.length;i++){
		List&amp;lt;String&amp;gt; inner = new ArrayList&amp;lt;String&amp;gt;();
		if(strs[i]!=&amp;quot;&amp;quot;){
			inner.add(strs[i]);
			for(int j=0 ;j&amp;lt;strs.length;j++){
				if(i!=j &amp;amp;&amp;amp; isAnagram2(strs[i],strs[j])){
					inner.add(strs[j]);
					strs[j] = &amp;quot;&amp;quot;;
				}
			}
			result.add(inner);
		}
	}
	return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;解二：把字先sort過，放進map, 如果已經存在了，代表有anagram了，把自己的index存進value的list即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; groupAnagrams(String[] strs) {
    List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; result = new ArrayList&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;();
	if(strs.length==0){
		return result;
	}
	Map&amp;lt;String, List&amp;lt;Integer&amp;gt;&amp;gt; table = new HashMap&amp;lt;String, List&amp;lt;Integer&amp;gt;&amp;gt;();
	for(int i=0;i&amp;lt;strs.length;i++){
		char[] c = strs[i].replaceAll(&amp;quot;\\s&amp;quot;, &amp;quot;&amp;quot;).toCharArray();
		Arrays.sort(c);
		String tmpSorted = new String(c);
		List&amp;lt;Integer&amp;gt; index = table.get(tmpSorted);
		if(index == null){
			index = new ArrayList&amp;lt;Integer&amp;gt;();
			index.add(i);
			table.put(tmpSorted, index);
		}else{
			index.add(i);
		}
	}
	for(String k : table.keySet()){
		List&amp;lt;String&amp;gt; inner = new ArrayList&amp;lt;String&amp;gt;();
		List&amp;lt;Integer&amp;gt; idx = table.get(k);
		for(Integer i : idx){
			inner.add(strs[i]);
		}
		Collections.sort(inner);
		result.add(inner);
	}
	return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;能夠改得更快嗎？&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Nexusguard Settings</title>
      <link>https://dixentw.github.io/s/page/nxgsetting/</link>
      <pubDate>Fri, 29 Apr 2016 17:49:51 +0800</pubDate>
      
      <guid>https://dixentw.github.io/s/page/nxgsetting/</guid>
      <description>&lt;p&gt;&lt;strong&gt;把有常回來找的東西貼在這裡:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;常用指令：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;LDAP密碼:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;最複雜的那個Csxxxx)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://serversforhackers.com/video/process-monitoring-with-upstart&#34;&gt;Upstart reference&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Nexusguard Project TODO</title>
      <link>https://dixentw.github.io/s/page/todonxg/</link>
      <pubDate>Fri, 29 Apr 2016 11:31:05 +0800</pubDate>
      
      <guid>https://dixentw.github.io/s/page/todonxg/</guid>
      <description>&lt;p&gt;Few things to do here.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Platform improvement&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;google cluster的etcd? 想知道寫入速度有多快可以sync&lt;/li&gt;
&lt;li&gt;ssdb client reconnect 加強？How?&lt;/li&gt;
&lt;li&gt;SSDB sync 還要走嗎？&lt;/li&gt;
&lt;li&gt;G-Center Monitor refactor到不會crash, 可以一直看？&lt;/li&gt;
&lt;li&gt;redis go client replace ssdb client?

&lt;ul&gt;
&lt;li&gt;已經沒有reconnect的功能了&amp;hellip;&lt;/li&gt;
&lt;li&gt;zeromq可以解這個問題嗎？&lt;/li&gt;
&lt;li&gt;DF 4003可以通 :) , sadly TD, DPI 4003不行&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;DNS project&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;User ACL: need to do?

&lt;ol&gt;
&lt;li&gt;Add new permission:AdminReadOnly&lt;/li&gt;
&lt;li&gt;Add new permission:AdminManager -&amp;gt; 開一個帳號，如果是這種User, 不要load zone file, 只給他管帳號的功能就好了&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;OP project&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;op panel refactor

&lt;ul&gt;
&lt;li&gt;$resource, model translation&lt;/li&gt;
&lt;li&gt;chart section code&lt;/li&gt;
&lt;li&gt;canvas chart (improvement)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>429</title>
      <link>https://dixentw.github.io/s/post/429/</link>
      <pubDate>Fri, 29 Apr 2016 11:25:55 +0800</pubDate>
      
      <guid>https://dixentw.github.io/s/post/429/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;重開DNS mi 的DFs&lt;/li&gt;
&lt;li&gt;需要report?寫report的人走了QQ&lt;/li&gt;
&lt;li&gt;where is KDD feature transfer??

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://kdd.ics.uci.edu/databases/kddcup99/kddcup99.html&#34;&gt;found&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://web.archive.org/web/20150205070216/http://nsl.cs.unb.ca/NSL-KDD/&#34;&gt;improved version&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;KDD99的training set還有testing set都齊了，目前工作重點在於建立RNN與LSTM的運算pipeline&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>242. Valid Anagram</title>
      <link>https://dixentw.github.io/s/leetcode/anagram/</link>
      <pubDate>Thu, 28 Apr 2016 22:43:25 +0800</pubDate>
      
      <guid>https://dixentw.github.io/s/leetcode/anagram/</guid>
      <description>&lt;p&gt;Given two strings s and t, write a function to determine if t is an anagram of s.&lt;/p&gt;

&lt;p&gt;For example,
s = &amp;ldquo;anagram&amp;rdquo;, t = &amp;ldquo;nagaram&amp;rdquo;, return true.&lt;br /&gt;
s = &amp;ldquo;rat&amp;rdquo;, t = &amp;ldquo;car&amp;rdquo;, return false.&lt;/p&gt;

&lt;p&gt;Note:
You may assume the string contains only lowercase alphabets.&lt;/p&gt;

&lt;p&gt;Follow up:
What if the inputs contain unicode characters? How would you adapt your solution to such case?&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;第一次想法：使用List, 把&lt;code&gt;s&lt;/code&gt;的characters都掃進去，然後針對&lt;code&gt;t&lt;/code&gt;的character, 一個一個去消掉Map裡面的character，最後map的size為空就是anagram。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public static boolean isAnagram(String s, String t) {
    List&amp;lt;Character&amp;gt; allChar = new ArrayList&amp;lt;Character&amp;gt;();
    for(int i=0; i&amp;lt;s.length();i++){
        allChar.add(s.charAt(i));
    }
    for(int j=0; j&amp;lt;t.length();j++){
    	Character c = new Character(t.charAt(j));
    	if(allChar.contains(c)){
    		allChar.remove(c);
    	}else{
    		return false;
    	}
    }
    return allChar.size() == 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;別人學來的：把s, t sort過一遍，對每個s, 去找t同一個index的字元，如果有不是，就不是anagram。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public static boolean isAnagram2(String s, String t){
	char[] scs = s.replaceAll(&amp;quot;\\s&amp;quot;, &amp;quot;&amp;quot;).toCharArray();
	char[] tcs = t.replaceAll(&amp;quot;\\s&amp;quot;, &amp;quot;&amp;quot;).toCharArray();
	Arrays.sort(scs);
	Arrays.sort(tcs);
	if(scs.length!=tcs.length){
		return false;
	}else{
		for(int i=0; i&amp;lt;scs.length; i++){
			if(scs[i]!=tcs[i]){
				return false;
			}
		}
		return true;
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>1. twosum</title>
      <link>https://dixentw.github.io/s/leetcode/twosum/</link>
      <pubDate>Thu, 28 Apr 2016 22:05:51 +0800</pubDate>
      
      <guid>https://dixentw.github.io/s/leetcode/twosum/</guid>
      <description>&lt;p&gt;Given an array of integers, return indices of the two numbers such that they add up to a specific target.
You may assume that each input would have exactly one solution.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;p&gt;Given nums = [2, 7, 11, 15], target = 9,
Because nums[0] + nums[1] = 2 + 7 = 9,&lt;/p&gt;

&lt;p&gt;return [0, 1].&lt;/p&gt;

&lt;p&gt;UPDATE (2016/2/13):
The return format had been changed to zero-based indices. Please read the above updated description carefully.&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;第一次解：使用兩個index, i, j, 跑兩個for迴圈，兩兩相比後可以得出解答 O(n*n)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;static int[] twoSum(int[] nums, int target) {
    for(int i=0; i&amp;lt;nums.length; i++){
        for(int j=0; j&amp;lt;nums.length;j++){
            if(i!=j&amp;amp;&amp;amp;(nums[i]+nums[j]==target)){
                return new int[]{i+1, j+1};
            }
        }
    }
    return new int[]{999,999};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;第二次解：two pass, 先掃一遍，把value跟index記在map, 第二次掃的時候，除了自己，使用map搜尋出剩餘的數 : 要搜尋的數 = target - 目前的數&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;static int[] twoSum1(int[] nums, int target) {
    Map&amp;lt;Integer, Integer&amp;gt; table = new HashMap&amp;lt;Integer, Integer&amp;gt;();
    for(int i=0; i&amp;lt;nums.length; i++){
        table.put(nums[i], i);
    }
    for(int i=0; i&amp;lt;nums.length;i++){
        int search = target - nums[i];
        Integer idx = table.get(search);
        if(idx==null){
            continue;
        }else{
            if(idx==i){
                continue;
            }else{
                return new int[]{idx, i};
            }
        }
    }
    return new int[]{999,999};
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>